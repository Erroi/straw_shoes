> 页面优化（如何让页面更快的显示和响应）

  三个阶段：
  * 加载阶段：从发出请求，到渲染出完整的页面过程，主要影响因素：网络和js脚本
  * 交换阶段：从加载完成到用户交互的整合过程，主要因素：js脚本
  * 关闭阶段：用户发出关闭指令后页面所在的清理操作

> 把能阻塞网页首次渲染的资源成为关键资源：图片、音频等文件不会阻塞首次渲染，而js、css会，因为构建DOM需要HTML和js，构造渲染树需要CSS文件

  三个核心因素：
  * 关键资源个数：js、css文件个数
  * 关键资源大小：内容越小，下载时间越短
  * 请求关键资源需要多少个RTT（往返时延，通常1个HTTp的数据包在14kb，所以1个0.1M的页面需拆成8个包来传输，也就是需要8个RTT），

> 优化原则：

  * 如何减少资源个数：1。js、css内联 
        2、若js没有DOM操作或CSSDOM操作，则改成sync或defer，变成非关键资源
        3、CSS添加媒体，取消阻止显现的标志
  * 如何减少关键资源的大小：1.压缩
        2、移除注释
  * 如何减少RTT：结合以上两点

> 交互阶段是如何渲染帧的

  主线程：js --> DOM、CSSOM --> 样式计算 --> 布局 --> 绘制
  合成线程：                                            --> 栅格化 --> 合成

  * js通过修改DOM或CSSOM来触发，如果在计算样式阶段，发生布局信息的修改，就会触发重排及后续一系列操作，如果只是颜色一类的修改，则直接进入绘制阶段
  * css实现一些变形、渐变、动画等特效,是在「合成线程」上执行的，不会触发重排和重绘，而且合成本身的速度非常快

> 交互阶段优化：渲染进程渲染帧的速度，渲染引擎是如何渲染帧的

  哪些因素影响帧的生成速度
  * 减少js脚本的执行时间：因为js函数一次执行时间太长会霸占主线程执行其他渲染任务的时间
        1. 将一次执行的函数分解多个任务执行，使每次执行的时间不要过长。
        2. web workers，当成主线程之外的一个线程，执行一些无关DOM操作且耗时的任务。
  * 避免强调同步布局
  * 避免布局抖动：禁了不要在修改DOM结构时再取查询一些属性值
  * 合理利用css合成动画，transform...因为是在合成线程上进行的
  * 避免频繁的垃圾回收：避免频繁的创建临时变量，尽可能优化存储结构

> 设计模式：MVC（将数据和视图分离：View和Model是不允许直接通信的，他们之间的通信都是由控制器Controller判断需要更新的模型数据）

  React和redux构建的MVC：
  虚拟DOM可以看成MVC的视图部分，控制器controller可以看作action、reducer、模型model可以看作store、state；
  * 控制器用来监测DOM的变化，一旦DOM发生变化，控制器会通知模型，让其更新数据
  * 模型数据更新好后，会通知视图
  * 视图会根据模型提供的数据生成新的虚拟DOM
  * 新的虚拟DOM生成好后，与之前的虚拟DOM比较，
  * react将变化的虚拟节点应用到DOM上，这样就会触发DOM节点的更新
  * DOM节点的变化会引发后续一系列渲染流水线的变化，从而实现页面的更新

> React Fiber优化原理

  * 将耗时高的任务分段，使得浏览器能够及时响应交互
    因为react：由于js单线程，stack reconcile过程会深度优先遍历所有的 Virtual DOM 节点，进行diff。
              整颗 Virtual DOM 计算完成后，将任务出栈才会释放主线程，所以，浏览器主线程被React更新状态任务占据的时候，用户与浏览器进行任何交互都不能得到反馈，只能等任务结束，才能得到浏览器的响应。

> HTTP/1的发展史

  * 请求头中增加「host」字段: 每个域名绑定唯一的一个ip地址，一个服务器对应一个ip，所以只支持一个域名，
                            但是现实中一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己单独的域名，都公用一个ip地址，
                            所以，请求头中增加 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 做不同的处理。
  * 动态内容大小的支持 「Chunk transfer」：浏览器根据 Content-length: 901 的大小来接收数据，但很多页面是动态生成的；
                                        便引入Chunk transfer 机制来解决这个问题，服务器将数据分割成若干个任意大小的数据块，每个数据块
                                        发送时附带上长度，最后一个使用0长度作为发送数据完成的标志。
  * content-encoding: 标明法误区采用的压缩方式，浏览器就以同样的方式解压，
  * content-type: text/html; charset=UTF-8： 浏览器以UTF-8的编码方式处理文件，按照HTML的方式解析改文件
  * Status Code: 状态码
  * Connect: keep-alive
  * User-Agent: 客户端设备信息

  * HTTP/1.1的问题：对带宽的利用率却不理想，比如100M带宽，实际下载速度能达到12.5M/S，而采用HTTP/1.1，最大只能使用到2.5M/S
                  带宽：指每秒最大能发送或者接收的字节数
                  上行带宽：每秒能发送的最大字节数
                  下行带宽：每秒能接收的最大字节数
                  原因：1.TCP的慢启动
                        2.同时开启多个TCP连接，这些连接会竞争固定带宽，影响关键资源的下载速度
                        3.队头阻塞（TCP通道中，某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求）

  * HTTP/2的优势：1.一个域名只使用一个TCP长连接来传输数据，使整个资源的下载只需要一次慢启动，同时避免多个TCP连接竞争的问题
                2.多路复用机制
                HTTP/2 添加了一个二进制分帧层：
                a、 first，浏览器准备好请求数据，包括请求行、请求头、请求体POST
                b、这些数据经过二进制分帧层处理后，会被转换为一个个带有请求ID编号的帧，通过协议将这些帧发送给服务器
                c、服务器接收到所有帧后，会将所有所有相同ID的帧合并为一条完整的请求信息
                d、然后服务器处理改条请求，并将处理的请求发送至二进制分帧层
                e、二进制分帧层会将这些响应数据转换为一个个带有请求ID编号的帧，经过协议栈发送给浏览器
                f、浏览器接收到响应帧之后，会根据ID编号将帧的数据提交给对应的请求
                
                3.可以设置请求的优先级，让重要的数据先送达
                4.服务器推送，直接将数据提前推送到浏览器
                  在接收到HTMl请求之后，附带将要使用的CSS文件和Javascript文件一并发送给浏览器，
                  当浏览器解析完HTML文件后，竟能直接拿到需要的CSS文件和js，对首次打开页面速度起到直观重要的作用
                5.头部压缩

  * HTTP/2的问题：对头阻塞（在TCP传输过程中，由于单个数据包的丢失而造成的阻塞成为TCP上的队头阻塞）
                1. 由于HTTP/2是一个TCP长连接，如果任意一个数据包丢失，就会阻塞改TCP连接中的所有请求。
                2. TCP建立连接的延时
                网络延迟：又称为RTT（Round Trip Time）浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为RTT
                TCP在建立连接时，需要和服务器进行 三次握手 来确认连接成功，需要消耗1.5个RTT之后才能进行数据传输。同时HTTPS的TLS也需要RTT

  * TCP协议的缺点：队头阻塞、建立连接延迟
                1. 中间设备的僵化，防火墙、NAT、交换机、操作系统等很少升级，致使tcp不能升级
                
  * HTTP/3特点：1. 采用UDP协议，基于UDP实现类似于 TCP的多路数据流、传输可靠性等功能，称为 QUIC 协议。
  * QUIC 协议的功能：1. 实现来类似 TCP 的流量控制， 传输可靠性的功能
                   2. 集成了 TLS 加密功能，
                   3. 实现了 HTTP/2 的多路复用功能
                   4. 实现了快速握手功能




